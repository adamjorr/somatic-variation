#!usr/bin/env perl
#get_flanks.pl

=head1 NAME

get_flanks - Get flanking sequences for a SNP from DiscoSNP++ and another set of SNPs.

=head1 SYNOPSIS

perl get_flanks.pl -d snps.vcf -v more_snps.vcf -r reference.fasta <discosnp.fasta

This will produce 3 files; one with only DiscoSNP++ SNPs, one with SNPs that overlapped, and one with only other SNPs.

perl get_flanks.pl -v snps.vcf -r reference.fasta > flanks.txt

Without -d, allows any vcf to be given with v and prints flanking sequence of all variants to stdout.

Use perldoc get_flanks.pl for even more help.

Options:

=over 8

=item -d | --discosnp FILE

Name of the DiscoSNP++-generated mapped VCF file.

=item --vcf | -v FILE

Name of the other VCF file containing mapped SNPs.

=item STDIN

The fasta file generated by DiscoSNP++.

=item --ref | -r FILE

Name of the reference used to map the SNPs.

=item --help | -h | -?

Prints help information

=back

=head1 DESCRIPTION

Reads DiscoSNP++-generated mapped VCF files and the accompanying
fasta file (generated with the -T option) and prints 3 files with
location and flanking sequence information. One file contains only
DiscoSNP++ SNPs, one contains SNPs that overlapped in both VCFs,
and one contains the other SNPs. The output fasta will have the SNP
capitalized with all surrounding sequences in lower case. Note
that this is different from the default DiscoSNP++ output, which
prints the entire bubble in upper case and the surrounding contigs
in lowercase.

=cut

use strict;
use warnings;
use Vcf;
use Bio::SeqIO;
use Getopt::Long;
use List::MoreUtils qw(any);
use Pod::Usage;

my $vcffile;
my $help = 0;
my $flanksize = 200;
my $reffile;
my $discofile;
GetOptions(	'discosnp|d=s' => \$discofile,
			'vcf|v=s' => \$vcffile,
			'ref|r=s' => \$reffile,
			'help|h|?' => \$help);
pod2usage(1) if $help;
die "Nonexistant or unreadable reference $reffile" unless defined_readable($reffile);
die "Nonexistant or unreadable vcf file $vcffile" unless defined_readable($vcffile);
if (! defined $discofile){
	warn("No discoSNP file detected, starting in simple mode\n");
	simple_mode();
	exit;
}
else{
	die "Cannot read $discofile" unless -r $discofile;
	print_output();
	exit;
}

# -----------------------

#Takes the name of a file and checks if it has been defined and
#if the file is readable
sub defined_readable{
	my $file = shift;
	if (defined $file){
		return -r $file;
	}
	return 0;
}


#Takes a fasta file and returns a hash with the IDs as keys
#and the sequences as values.
sub chr_seq{
	my $reffile = shift;
	my %chrids;
	my $seqio = Bio::SeqIO->newFh(-format => 'Fasta', -file => $reffile);
	while(<$seqio>){
		$chrids{$_ -> id()} = $_ -> seq();
	}
	return \%chrids;
}

#Takes a VCF file and a hash with IDs as keys and sequences as values
#and creates a nested hash with IDs as keys and location as values.
#The chr_seq hash is used to verify the chromosome in the VCF exists.
sub dids_from_vcf{
	my $vcffile = shift;
	my $chr_seq_ref = shift;
	my %chr_seq = %$chr_seq_ref;
	my %ids;
	my $vcf = Vcf->new(file=>"$vcffile");
	$vcf->parse_header();
	while (my $x = $vcf -> next_data_array()){
		my $chr = $$x[0];
		if (any {$_ eq $chr} keys %chr_seq){
			$ids{$$x[2]} = {'chr' => $chr, 'pos' => $$x[1]};
		}
		else{
			$ids{$$x[2]} = {'chr' => '', 'pos' => $$x[1]};
		}
	}
	return \%ids;
}

#Takes a chromosome, position, flanksize, and a reference to a hash with
#IDs as keys and sequences as values and returns the SNP with flanking
#regions of size flanksize. The SNP is capitalized with the flanking region
#in lowercase.
sub flanking_ref{
	my $chr = shift;
	my $pos = shift;
	my $flanksize = shift;
	my $chrseqref = shift;
	my %chrseq = %$chrseqref;

	my $seq = $chrseq{$chr};
	my $startloc;
	if ($flanksize > $pos - 1){
		$startloc = 0;
		$flanksize = $pos - 1;
	}
	else{
		$startloc = $pos - 1 - $flanksize;
	}
	return lc(substr($seq, $startloc, $flanksize)) . uc(substr($seq,$pos - 1,1)) . lc(substr($seq, $pos, $flanksize));
}

#Takes a reference to a hash with keys of discoSNP IDs and values of sequence data,
#an ID and a position and extracts the flanking region.
sub flanking_disco{
	my $did_seqref = shift;
	my %did_seq = %$did_seqref;
	my $id = shift;
	my $pos = shift;

	my $seq = $did_seq{$id};
	die "Can't find seq for $id!" unless $seq;
	return lc(substr($seq,0,$pos)) . uc(substr($seq,$pos,1)) . lc(substr($seq,$pos + 1));
}

#Creates a reference to a hash with keys of discoSNP IDs and values of sequence data
#Reads this from STDIN.
sub discoid_seq{
	my %did_seq;
	my %did_loc;
	my $seqio = Bio::SeqIO->newFh(-format => 'Fasta', -fh => \*STDIN);
	while (<$seqio>){
		my $full_id = $_ -> id();
		my $id = (split('_',(split('\|',$full_id))[0]))[-1];
		$did_seq{$id} = $_ -> seq();

		my $loc = (split(':',(split('_',(split('\|',$full_id))[1]))[1]))[1] + (split('_',(split('\|',$full_id))[6]))[-1];
		$did_loc{$id} = $loc;
	}
	return (\%did_seq , \%did_loc);
}

#Takes the name of a vcf file and a reference to a hash with chromosomes as keys
#and sequences as values and returns a reference to a hash with arbitrary IDs and
#location data as values.
sub othervcflocs{
	my $vcffile = shift;
	my $chr_seq_ref = shift;
	my %chr_seq = %$chr_seq_ref;
	my %ids;
	my $counter = 0;

	my $vcf = Vcf->new(file=>"$vcffile");
	$vcf -> parse_header();
	while (my $x = $vcf -> next_data_array()){
		my $chr = $$x[0];
		my $pos = $$x[1];
		$ids{$counter} = {'chr' => $chr, 'pos' => $pos};
		$counter++;
	}
	return \%ids;
}

#Takes a reference to a hash with discoSNP++ IDs as keys and locations as values
#and a reference to a hash with other IDs as keys and locations as values and
#finds those which overlap. The return value is an array with references to 3 hashes
#containing IDs as keys and locations as values.
sub find_mutual_snps{
	#(%left, %both, %right)
	my $did_locr = shift;
	my $otherid_locr = shift;
	my %did_loc = %$did_locr;
	my %otherid_loc = %$otherid_locr;
	my %left;
	my %both;
	my %right;

	for my $key (sort keys %did_loc){
		my $dloc = $did_loc{$key};
		if (any {$otherid_loc{$_}->{'chr'} eq $dloc->{'chr'} && $otherid_loc{$_}->{'pos'} == $dloc->{'pos'}} keys %otherid_loc){
			$both{$key} = $did_loc{$key};
		}
		else{
			$left{$key} = $did_loc{$key};
		}
	}

	for my $key (sort keys %otherid_loc){
		if (! any {%{$did_loc{$_}} == %{$otherid_loc{$key}}} ){
			$right{$key} = $otherid_loc{$key};
		}
	}
	return (\%left, \%both, \%right);
}

#Main function prints the files.
sub print_output{
	my $chr_seq_ref = chr_seq($reffile);
	my $didsr = dids_from_vcf($discofile, $chr_seq_ref);
	my $otherids = othervcflocs($vcffile, $chr_seq_ref);
	(my $donlyr, my $bothr, my $otheronlyr) = find_mutual_snps($didsr, $otherids);
	my %donly = %$donlyr;
	my %both = %$bothr;
	my %otheronly = %$otheronlyr;

	(my $dseqsr, my $dlocr) = discoid_seq();
	my %dseqs = %$dseqsr;
	my %dlocs = %$dlocr;
	my %discoflanks;
	my %otherflanks;
	open(my $discofh, ">", 'discoflanks.txt') or die $!;
	open(my $bothfh, ">", 'bothflanks.txt') or die $!;
	open(my $otherfh, ">", 'gatkflanks.txt') or die $!;
	print{$discofh}(join("\t",qw'DISCOSNP_ID LOC FLANKS'),"\n");
	print{$bothfh}(join("\t",qw'DISCOSNP_ID LOC FLANKS'),"\n");
	print{$otherfh}(join("\t",qw'LOC FLANKS'),"\n");


	for my $key (sort keys %donly){
		my $pos = $donly{$key}->{'pos'};
		my $flanks = flanking_disco($dseqsr, $key, $dlocs{$key});
		my $chr = $donly{$key}->{'chr'};
		if ($chr){
			print{$discofh}(join("\t",$key, $chr . ':' .  $pos, $flanks),"\n");	
		}
		else{
			print{$discofh}(join("\t",$key, '', $flanks),"\n");	
		}
		
	}
	close $discofh;

	for my $key (sort keys %both){
		my $pos = $both{$key}->{'pos'};
		my $flanks = flanking_disco($dseqsr, $key, $dlocs{$key});
		print{$bothfh}(join("\t",$key, $both{$key}->{'chr'} . ':' . $pos, $flanks),"\n");
	}
	close $bothfh;

	for my $key (sort keys %otheronly){
		my $pos = $otheronly{$key}->{'pos'};
		my $chr = $otheronly{$key}->{'chr'};
		my $flanks = flanking_ref($chr, $pos, $flanksize, $chr_seq_ref );
		print{$otherfh}(join("\t",$chr . ':' . $pos, $flanks),"\n");
	}
	close $otherfh;
	exit;
}

#Prints flanks for any arbitrary VCF/FASTA combo without doing
#other comparisons.
sub simple_mode{
	my $chr_seq_ref = chr_seq($reffile);
	my $otherids = othervcflocs($vcffile, $chr_seq_ref);
	my %vcfids = %$otherids;
	for my $key (sort keys %vcfids){
		my $pos = $vcfids{$key}->{'pos'};
		my $chr = $vcfids{$key}->{'chr'};
		my $flanks = flanking_ref($chr, $pos, $flanksize, $chr_seq_ref );
		print(join("\t",$chr . ':' . $pos, $flanks),"\n");
	}

}

# ------------------
# DEPRECATED
# ------------------
sub print_fasta{
	my @ids = @_;
	my $seqio = Bio::SeqIO->newFh(-format => 'Fasta', -fh => \*STDIN);
	my $seqout = Bio::SeqIO->newFh(-format => 'Fasta', -fh => \*STDOUT);
	while (<$seqio>){
		my $full_id = $_ -> id();
		(my $name, my $full_snp) = (split('\|',$full_id))[0,1];
		if (any {$_ eq $name} @ids){
			my $snp = (split(',',$full_snp))[0];
			my @split = split('_',$snp);
			(my $num, my $pos) = split(':',$split[1]);
			(my $ref, my $alt) = split('\/',$split[2]);
			my $seqstr = $_ -> seq();
			my ($uppers) = $seqstr =~ m/[A-Z]+/g;
			my $upperstart = index($seqstr,$uppers);
			$seqstr = lc($seqstr);
			substr($seqstr,$upperstart + $pos,1) = uc(substr($seqstr,$upperstart + $pos,1));
			$_ -> seq($seqstr);
			print $seqout $_;
		}
	}
}

__END__
